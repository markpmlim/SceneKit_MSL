//
//  ViewController.swift
//  InterpolatedColour
//
//  Created by Mark Lim Pak Mun on 31/03/2019.
//  Copyright Â© 2019 Incremental Innovation. All rights reserved.

import Cocoa
import SceneKit
import MetalKit

class ViewController: NSViewController, SCNSceneRendererDelegate {

    var scnView: SCNView {
        return self.view as! SCNView
    }

    var device: MTLDevice!
    var outputTexture: MTLTexture!

    override func viewDidLoad() {
        super.viewDidLoad()
        device = MTLCreateSystemDefaultDevice()
        outputTexture = createTexture(device: device)

        scnView.scene = buildScene()
        scnView.allowsCameraControl = true
        scnView.showsStatistics = true
        scnView.delegate = self
        scnView.backgroundColor = NSColor.lightGray
    }

    override var representedObject: Any? {
        didSet {
            // Update the view, if already loaded.
        }
    }

    // Call a compute kernel function to create an instance of MTLTexture
    func createTexture(device: MTLDevice) -> MTLTexture {
        // Instantiate a texture descriptor with the appropriate properties.
        let descriptor = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .bgra8Unorm,
                                                                  width: 256,
                                                                  height: 256,
                                                                  mipmapped: false)
        descriptor.textureType = MTLTextureType.type2D
        descriptor.usage = [MTLTextureUsage.shaderRead, MTLTextureUsage.shaderWrite]
        let outputTexture = device.makeTexture(descriptor: descriptor)

        let commandQueue = device.makeCommandQueue()
        let defaultLibrary = device.newDefaultLibrary()!

        let kernelFunction = defaultLibrary.makeFunction(name: "kernel_function")!
        var computePipelineState: MTLComputePipelineState!
        do {
            computePipelineState = try! device.makeComputePipelineState(function: kernelFunction)
        }

        let commandBuffer = commandQueue.makeCommandBuffer()
        commandBuffer.addCompletedHandler {
            (commandBuffer) in
            //print("texture is ready")
        }
        let computeEncoder = commandBuffer.makeComputeCommandEncoder()
        computeEncoder.setComputePipelineState(computePipelineState)
        computeEncoder.setTexture(outputTexture,
                                  at: 0)
        let threadgroupSize = MTLSizeMake(16, 16, 1)        // # of threads per group
        var threadgroupCount = MTLSizeMake(1, 1, 1)         // # of thread groups per gird
        threadgroupCount.width  = (outputTexture.width + threadgroupSize.width - 1) / threadgroupSize.width
        threadgroupCount.height = (outputTexture.height + threadgroupSize.height - 1) / threadgroupSize.height
        computeEncoder.dispatchThreadgroups(threadgroupCount,
                                            threadsPerThreadgroup: threadgroupSize)
        computeEncoder.endEncoding()
        commandBuffer.commit()
        commandBuffer.waitUntilCompleted()

        return outputTexture
    }

    func buildScene() -> SCNScene {

        let geometry = SCNPlane(width:10, height:10)
        let geometryNode = SCNNode(geometry: geometry)

        let program = SCNProgram()
        program.vertexFunctionName = "vertex_function"
        program.fragmentFunctionName = "fragment_function"

        geometryNode.geometry?.firstMaterial?.program = program
        // The method setValue:forKey: works in Metal but not in OpenGL
        // The Metal SCNProgram method handleBinding(ofBufferNamed:frequency:handler:)
        // is not used since the custom data is passed once.
        let imageProperty = SCNMaterialProperty(contents: outputTexture)
        geometryNode.geometry?.firstMaterial?.setValue(imageProperty,
                                                       forKey: "diffuseTexture")

        geometryNode.geometry?.firstMaterial?.isDoubleSided = true
        // We don't really need to instantiate an instance of SCNProgram.
        // The texture generated by the compute kernel function can be assigned 
        // to the contents object of the diffuse material property as follows:
/*
        geometry.firstMaterial?.diffuse.contents = outputTexture
        geometry.firstMaterial?.isDoubleSided = true
*/
        let scene = SCNScene()
        //scene.background.contents = outputTexture
        scene.rootNode.addChildNode(geometryNode)
        return scene
    }
}
